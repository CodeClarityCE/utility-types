package ecosystem

import (
	"fmt"
	"log"
)

// VulnerabilityInfo represents vulnerability information in a generic way
type VulnerabilityInfo struct {
	Id              string   `json:"id"`
	PackageName     string   `json:"packageName"`
	VersionAffected string   `json:"versionAffected"`
	Severity        string   `json:"severity"`
	Score           float64  `json:"score"`
	Description     string   `json:"description"`
	References      []string `json:"references"`
	FixedVersions   []string `json:"fixedVersions"`
	Ecosystem       string   `json:"ecosystem"`
	Source          string   `json:"source"` // OSV, NVD, etc.
}

// VulnerabilityWorkspaceInfo represents workspace vulnerability information
type VulnerabilityWorkspaceInfo struct {
	Vulnerabilities []VulnerabilityInfo `json:"vulnerabilities"`
}

// VulnerabilityOutput represents the complete vulnerability analysis output
type VulnerabilityOutput struct {
	WorkSpaces     map[string]VulnerabilityWorkspaceInfo `json:"workSpaces"`
	AnalysisStatus string                                `json:"status"`
}

// VulnerabilityResultMerger provides merge functionality for vulnerability analysis results
type VulnerabilityResultMerger struct {
	*GenericResultMerger[VulnerabilityOutput]
	utils *MergerUtils
}

// NewVulnerabilityResultMerger creates a new vulnerability result merger
func NewVulnerabilityResultMerger(strategy MergeStrategy) *VulnerabilityResultMerger {
	utils := NewMergerUtils()
	
	merger := &VulnerabilityResultMerger{
		GenericResultMerger: NewGenericResultMerger(strategy, mergeVulnerabilityOutputs),
		utils:              utils,
	}
	
	return merger
}

// mergeVulnerabilityOutputs is the merge function for vulnerability outputs
func mergeVulnerabilityOutputs(outputs []VulnerabilityOutput) VulnerabilityOutput {
	if len(outputs) == 0 {
		return VulnerabilityOutput{
			WorkSpaces:     make(map[string]VulnerabilityWorkspaceInfo),
			AnalysisStatus: "FAILURE",
		}
	}

	if len(outputs) == 1 {
		return outputs[0]
	}

	utils := NewMergerUtils()
	
	// Start with empty merged output
	merged := VulnerabilityOutput{
		WorkSpaces:     make(map[string]VulnerabilityWorkspaceInfo),
		AnalysisStatus: "SUCCESS",
	}

	// Track if any analysis failed
	hasFailures := false
	totalVulnerabilities := 0

	// Merge all outputs
	for _, output := range outputs {
		if output.AnalysisStatus != "SUCCESS" {
			hasFailures = true
			log.Printf("Warning: merging failed vulnerability analysis output")
			continue
		}

		// Merge workspaces
		for workspaceName, workspace := range output.WorkSpaces {
			if existingWorkspace, exists := merged.WorkSpaces[workspaceName]; exists {
				// Merge vulnerabilities for existing workspace
				merged.WorkSpaces[workspaceName] = mergeVulnerabilityWorkspaces(existingWorkspace, workspace, utils)
			} else {
				// Add new workspace
				merged.WorkSpaces[workspaceName] = workspace
			}
			
			totalVulnerabilities += len(workspace.Vulnerabilities)
		}
	}

	// Set final status
	if hasFailures && len(merged.WorkSpaces) == 0 {
		merged.AnalysisStatus = "FAILURE"
	}

	utils.LogMergeOperation(
		"vulnerability analysis",
		len(outputs),
		fmt.Sprintf("%d workspaces, %d total vulnerabilities", len(merged.WorkSpaces), totalVulnerabilities),
	)

	return merged
}

// mergeVulnerabilityWorkspaces merges two vulnerability workspace infos
func mergeVulnerabilityWorkspaces(existing, new VulnerabilityWorkspaceInfo, utils *MergerUtils) VulnerabilityWorkspaceInfo {
	// Merge vulnerabilities, removing duplicates by ID + package + version
	merged := VulnerabilityWorkspaceInfo{
		Vulnerabilities: deduplicateVulnerabilities(existing.Vulnerabilities, new.Vulnerabilities),
	}

	return merged
}

// deduplicateVulnerabilities removes duplicate vulnerabilities based on ID, package, and version
func deduplicateVulnerabilities(existing, new []VulnerabilityInfo) []VulnerabilityInfo {
	seen := make(map[string]VulnerabilityInfo)

	// Add existing vulnerabilities
	for _, vuln := range existing {
		key := generateVulnerabilityKey(vuln)
		seen[key] = vuln
	}

	// Add new vulnerabilities (will overwrite duplicates with newer info)
	for _, vuln := range new {
		key := generateVulnerabilityKey(vuln)
		seen[key] = vuln
	}

	// Convert back to slice
	result := make([]VulnerabilityInfo, 0, len(seen))
	for _, vuln := range seen {
		result = append(result, vuln)
	}

	return result
}

// generateVulnerabilityKey creates a unique key for a vulnerability
func generateVulnerabilityKey(vuln VulnerabilityInfo) string {
	return fmt.Sprintf("%s|%s|%s", vuln.Id, vuln.PackageName, vuln.VersionAffected)
}

// VulnerabilityStatsCalculator provides utilities for calculating vulnerability statistics
type VulnerabilityStatsCalculator struct{}

// NewVulnerabilityStatsCalculator creates a new stats calculator
func NewVulnerabilityStatsCalculator() *VulnerabilityStatsCalculator {
	return &VulnerabilityStatsCalculator{}
}

// CalculateStats calculates vulnerability statistics from merged results
func (calc *VulnerabilityStatsCalculator) CalculateStats(output VulnerabilityOutput) VulnerabilityStats {
	stats := VulnerabilityStats{
		Total:        0,
		BySeverity:   make(map[string]int),
		ByEcosystem:  make(map[string]int),
		BySource:     make(map[string]int),
		UniquePackages: make(map[string]bool),
	}

	// Calculate stats across all workspaces
	for _, workspace := range output.WorkSpaces {
		for _, vuln := range workspace.Vulnerabilities {
			stats.Total++
			stats.BySeverity[vuln.Severity]++
			stats.ByEcosystem[vuln.Ecosystem]++
			stats.BySource[vuln.Source]++
			stats.UniquePackages[vuln.PackageName] = true
		}
	}

	stats.UniquePackageCount = len(stats.UniquePackages)
	return stats
}

// VulnerabilityStats represents calculated vulnerability statistics
type VulnerabilityStats struct {
	Total              int            `json:"total"`
	BySeverity         map[string]int `json:"bySeverity"`
	ByEcosystem        map[string]int `json:"byEcosystem"`
	BySource           map[string]int `json:"bySource"`
	UniquePackages     map[string]bool `json:"-"` // Internal use only
	UniquePackageCount int            `json:"uniquePackageCount"`
}